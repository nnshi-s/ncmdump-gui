// generated by Fast Light User Interface Designer (fluid) version 1.0307

#include "ui.h"
#include "logic.h"

user_interface::user_interface()
{
	// Text Buffer
	text_buffer_ = new Fl_Text_Buffer(8 * 1024, 1024);

	// UI Layout
	Fl_Window* w;
	{
		Fl_Window* o = new Fl_Window(410, 480, "ncmdump-gui");
		w = o;
		if (w) { /* empty */ }
		o->color((Fl_Color)55);
		o->user_data((void*)(this));
		{
			input_path_ = new Fl_Input(47, 15, 301, 28, "Path:");
			input_path_->box(FL_BORDER_BOX);
			input_path_->color((Fl_Color)55);
			input_path_->when(FL_WHEN_NEVER);
		} // Fl_Input* input_path_
		{
			btn_sel_path_ = new Fl_Button(353, 15, 43, 28, "@fileopen");
			btn_sel_path_->box(FL_BORDER_BOX);
			btn_sel_path_->color((Fl_Color)55);
			btn_sel_path_->labeltype(FL_SHADOW_LABEL);
		} // Fl_Button* btn_sel_path_
		{
			check_skip_ = new Fl_Check_Button(12, 52, 125, 28, " Skip converted");
			check_skip_->down_box(FL_BORDER_BOX);
			check_skip_->color((Fl_Color)55);
			check_skip_->selection_color(FL_GRAY0);
			check_skip_->when(FL_WHEN_RELEASE);
			check_skip_->clear();
		} // Fl_Check_Button* check_skip_
		{
			check_delete_ = new Fl_Check_Button(141, 52, 156, 28, " Delete original ncm");
			check_delete_->down_box(FL_BORDER_BOX);
			check_delete_->color((Fl_Color)55);
			check_delete_->selection_color(FL_GRAY0);
			check_delete_->when(FL_WHEN_RELEASE);
			check_delete_->clear();
		} // Fl_Check_Button* check_delete_
		{
			btn_stop_ = new Fl_Button(300, 56, 41, 22, "@square");
			btn_stop_->box(FL_BORDER_BOX);
			btn_stop_->color((Fl_Color)55);
		} // Fl_Button* btn_stop_
		{
			btn_go_ = new Fl_Button(354, 56, 41, 22, "@refresh");
			btn_go_->box(FL_BORDER_BOX);
			btn_go_->color((Fl_Color)55);
		} // Fl_Button* btn_go_
		{
			progressbar_ = new Fl_Progress(10, 87, 391, 25);
			progressbar_->box(FL_BORDER_BOX);
			progressbar_->color((Fl_Color)55);
			progressbar_->selection_color(FL_GRAY0);
			progressbar_->when(FL_WHEN_NEVER);
			progressbar_->minimum(0.0f);
			progressbar_->maximum(1.0f);
			progressbar_->value(0.0f);
		} // Fl_Progress* progressbar_
		{
			text_disp_log_ = new Fl_Text_Display(10, 121, 392, 351);
			text_disp_log_->box(FL_BORDER_BOX);
			text_disp_log_->color((Fl_Color)55);
			text_disp_log_->when(FL_WHEN_NEVER);
			text_disp_log_->buffer(text_buffer_);
		} // Fl_Text_Display* text_disp_log_
		o->end();
	} // Fl_Window* o
	w->end();
	w->show();

	// Binding callbacks
	bind_callbacks();
}

user_interface::~user_interface()
{
	if(converter_thread && converter_thread->joinable())
	{
		stop_ = true;
		converter_thread->join();
		delete converter_thread;
		converter_thread = nullptr;
	}
}

void user_interface::set_progress(const float f)
{
	Fl::lock();
	progressbar_->value(f);
	Fl::awake();
	Fl::unlock();
}

void user_interface::log_append(const char* s)
{
	auto pos = text_buffer_->length();
	Fl::lock();
	text_buffer_->append(s);
	text_display_set_pos(pos + 1);
	// trigger event loop handling in the main thread
	Fl::awake();
	Fl::unlock();
}

void user_interface::bind_callbacks()
{
	btn_sel_path_->callback(btn_sel_path_cb, this);
	btn_stop_->callback(btn_stop_cb, this);
	btn_go_->callback(btn_go_cb, this);
	text_disp_log_->callback(text_disp_log_callback, this);
}


